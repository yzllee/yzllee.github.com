<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyn&#39;s blog</title>
  
  <subtitle>咸鱼好吃吗</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://yzllee.github.io/blog/"/>
  <updated>2020-05-08T05:35:17.539Z</updated>
  <id>https://yzllee.github.io/blog/</id>
  
  <author>
    <name>Lyn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript EventLoop(浏览器篇)</title>
    <link href="https://yzllee.github.io/blog/2020/04/10/eventLoop/"/>
    <id>https://yzllee.github.io/blog/2020/04/10/eventLoop/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2020-05-08T05:35:17.539Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript 是一门单线程、非阻塞的脚本语言，目的是为了实现与浏览器的交互。</p><a id="more"></a><h2 id="JavaScript-为什么是单线程的？"><a href="#JavaScript-为什么是单线程的？" class="headerlink" title="JavaScript 为什么是单线程的？"></a>JavaScript 为什么是单线程的？</h2><p>因为为了处理浏览器与用户之间的交互、网络请求以及DOM操作，这就决定了 JavaScript 必须是单线程的，否则就会有产生复杂的同步问题。假设 JavaScript 有两个线程，在一个线程中用户操作了 一个DOM ，另一个线程中又删除了这个 DOM，那这个时候浏览器要怎么处理，以哪个线程为准呢？</p><p>既然是单线程的，那么 JavaScript 的任务就得一个个排队执行，如果遇到到耗时的任务（比如一个网络请求很慢），那后面的任务就执行不了，浏览器就卡着了。这与开头说的 JavaScript 是非阻塞的相矛盾。为了防止主线程的阻塞， JavaScript 就有了 同步 和 异步 的概念。 </p><h2 id="JavaScript-中的同步和异步"><a href="#JavaScript-中的同步和异步" class="headerlink" title="JavaScript 中的同步和异步"></a>JavaScript 中的同步和异步</h2><p><strong>同步</strong>： 如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的。同步就会产生阻塞，如下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds() - s &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">wait();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"执行结束！"</span>);</span><br></pre></td></tr></table></figure><br>上面的代码中，console.log() 需要等 wait 函数执行完毕后才会执行。</p><p><strong>异步</strong>： 如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的手段得到（例如回调函数），这就是异步。例如 Ajax 操作。调用异步函数后，调用者不会立即得到结果，当异步函数获得结果时，会通过回调函数返回调用的结果，所以异步函数不会阻塞线程。  </p><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><p>先了解一下数据结构。</p><p><strong>堆（heap）</strong>：基于树抽象数据类型的一种特殊数据结构。</p><p><strong>栈（stack）</strong>: 栈是遵循后进先出 (LIFO) 原则的有序集合。JavaScript 是单线程的也主要体现在这，因为一个线程只有一个调用栈。调用栈也是有深度限制的，当你写了一个无线递归函数时，浏览器会抛出错误警告（Uncaught RangeError: Maximum call stack size exceeded）。</p><p><strong>队列（queue</strong>）:  队列是遵循先进先出 (FIFO) 原则的有序集合。</p><p>观察一下浏览器中的Event Loop执行模型：<br><img src="/images/EventLoop.png" alt="Loop"></p><p>如图可知，JavaScript 中分为 <strong>堆内存</strong> 和 <strong>栈内存</strong>。</p><p>JavaScript 中的引用数据类型的大小是不固定的，所以它们就储存在堆内存中。JavaScript 不允许直接访问堆内存中的位置，所以也不能直接去操作它的内存空间，而是操作 <strong>对象的引用</strong>。引用数据类型（ 对象(Object) ）的指针储存在栈内存中，该指针指向了堆内存中该实体的起始地址。顺带一提，当形成闭包的时候，实际上作用域链也是保存到了堆中。</p><p>JavaScript 中的基本数据类型就储存在栈内存中，它们占用的大小和空间固定，是直接 <strong>按值来访问</strong> 的。</p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>当打开一个网页时，浏览器会将代码传递给引擎去执行，引擎首页会创建一个全局执行环境。全局环境中的代码自上而下有顺序的执行，当遇到一个函数时，JavaScript 会生成一个与这个函数对应的执行环境，又叫做 <strong>执行上下文（Context）</strong>[1]。这个执行上下文中保存着这个函数的私有作用域、作用域链、参数、此函数作用域中定义的变量和 this 的指向。当这个函数执行完以后，当前执行上下文将从栈中弹出，上下文的控制权限将转移到当前执行栈的下一个执行上下文。当一系列的函数被调用时，这些函数就会按照顺序排列在一个地方，按照类似于栈的控制机制执行，这个地方就是称之为的执行栈。</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>任务队列是一个存放着很多 <strong>异步任务</strong> 的有序 <strong>集合</strong>（注意不是队列，因为执行的机制与队列的执行机制是不一样的。在队列中，是队列中的第一个出队。而在任务队列中，是事件循环执行模型抓取任务队列中第一个可以执行的任务）。一个事件循环中存在一个或多个任务队列，每个任务都来自一个特定的任务源。来自特定任务源和指向特定的事件循环的所有任务都必须被添加到同一个任务队列，来自不同任务源的任务可以被添加到不同的任务队列中。  </p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。每个代理都有一个关联的事件循环，该事件循环对于该代理是唯一的。</p><p>HTML标准中的事件循环进程模型，概括如下：</p><ol><li><p>选择一个包含至少有一个可执行的任务的任务队列作为当前的要执行的任务队列（下面称为 <em>taskQueue</em>），如果没有这样的队列，就跳转至 <strong>microtask 的执行步骤</strong>。</p></li><li><p>从 <em>taskQueue</em> 中选择第一个可执行的任务作为 <em>oldestTask</em>，从 <em>taskQueue</em> 中移除 <em>oldestTask</em>。</p></li><li><p>将事件循环的当前运行中的任务设置为 <em>oldestTask</em>。</p></li><li><p>执行任务。</p></li><li><p>将事件循环的当前运行中的任务设置为 null。</p></li><li><p>进入 microtask 执行步骤。</p></li><li><p>更新渲染</p></li><li><p>循环这整个过程…</p></li></ol><p>进入到 <strong>microtask 的执行步骤</strong>：</p><ol><li><p>如果执行 microtask 步骤标识为 true，则退出执行。</p></li><li><p>设置执行 microtask 步骤标识为 true。</p></li><li><p>如果事件循环中的微任务队列不为空：</p><p>3.1 设置事件循环的微任务队列中第一个任务为 <em>oldestMicrotask</em>。</p><p>3.2 将事件循环的当前运行中的任务设置为 <em>oldestMicrotask</em>。</p><p>3.3 执行 <em>oldestMicrotask</em>。</p><p>3.4 将事件循环的当前运行中的任务设置为 null。</p></li><li><p>将事件循环的 执行 microtask 步骤表示设置为 false。  </p></li></ol><p>下面是根据我理解的事件循环进程模型画出来的示意图。  </p><p><img src="/images/Process.png" alt="Process">  </p><p>用文字描述可以解释为：所有的同步任务都会在执行栈立即执行然后出栈，异步任务会进入到异步任务处理模块，然后把异步任务结果放到任务队列中。当执行栈中所有同步任务执行完以后就会去检查任务列队，如果任务队列为空，就会去检查微任务队列，如果有微任务就一次执行完所有的微任务。循环进行 <strong>任务入栈执行任务</strong>，<strong>栈为空</strong>，<strong>检查任务队列</strong> 的步骤，这个过程不断重复，这就是事件循环。</p><p><strong>总结：1.宏任务队列每执行完一个任务就会去检查微任务队列。2.微任务队列中的任务会按照顺序一次执行完成（微任务执行产生的微任务会被加入到队尾，在这个周期被执行），直至微任务队列为空。</strong>  </p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>宏任务：script(整体代码)、setTimeout、setInterval、I/O、事件、postMessage、 MessageChannel、setImmediate (Node.js)</p><p>微任务：Promise.then、 MutaionObserver、process.nextTick (Node.js)</p><p>引用文章《微任务、宏任务与 Event-Loop》中的例子来介绍一下宏任务与微任务的关系。</p><p>在银行办业务的时候，假设这个银行只有一个窗口，每个客户都会取号排队在这个窗口办理业务。把每一个客户比作 <strong>宏任务</strong>，那么接待下一位客户的过程就是 <strong>宏任务</strong> 进入到执行栈的过程。这些排队的客户就形成了一个 任务队列。当客户在窗口办理完业务，业务员会问客户，还有什么可以帮您的吗？这时候如果客户还有其他一些事情要办，那么在还会继续占用着窗口办理业务，其他客户也只能等着，客户的其他事情就像是 <strong>微任务</strong>。这表明，<strong>在当前微任务没有执行完成时，是不会执行下一个宏任务的</strong>。根据例子，可以总结出：<strong>宏任务与微任务不在同一个队列中，且微任务的执行优先于宏任务</strong>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>学习那么多理论知识，让我们来检查一下学习成果吧，下面抛出一道烂大街的笔试题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>心里想的答案与实际结果一样吗？不一样也没关系，不要气馁。是不是在 <strong>async/await</strong> 上遇到了的问题？让我帮帮你吧！</p><p><strong>async/await</strong> 只是语法糖而已，只要把它转换成 <strong>Promise</strong> 的形式，你就会一目了然了。例如下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// await 前面的代码</span></span><br><span class="line">    <span class="keyword">await</span> load();</span><br><span class="line">    <span class="comment">// await 后面的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch();</span><br></pre></td></tr></table></figure><p>await 前面的代码是同步的，调用函数的时候会直接执行；<strong>await load()</strong> 可以被转换成 <strong>Promise.resolve(load())</strong>；await 后面的代码则会被放到 <strong>Promise.then()</strong> 中。这样代码就会被转换成下面的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// await 前面的代码</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve(load()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// await 后面的代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch();</span><br></pre></td></tr></table></figure><p>试着转换一下测试题，然后重新运算一下结果，这样是不是就容易多了？</p><p>那么恭喜你，你已经掌握了本篇文章涉及的知识点。</p><p>说道最后：推荐去看一下 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">HTML5标准 - Event Loop</a> 原文。还有就是，好记性不如烂笔头，根据自己的理解，试着画一下 <strong>Event Loop 执行模型</strong> 的流程图来巩固一下知识吧！</p><blockquote><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">[MDN] 并发模型与事件循环</a><br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">HTML5标准 - Event Loop</a><br><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="noopener">Understanding Execution Context and Execution Stack in Javascript</a><br><a href="https://juejin.im/post/5cbc0a9cf265da03b11f3505" target="_blank" rel="noopener">最后一次搞懂 Event Loop</a><br><a href="https://vimeo.com/96425312" target="_blank" rel="noopener">Philip Roberts: Help, I’m stuck in an event-loop.</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，JavaScript 是一门单线程、非阻塞的脚本语言，目的是为了实现与浏览器的交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://yzllee.github.io/blog/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>个性化shell终端折腾</title>
    <link href="https://yzllee.github.io/blog/2017/03/04/shell/"/>
    <id>https://yzllee.github.io/blog/2017/03/04/shell/</id>
    <published>2017-03-04T08:05:32.000Z</published>
    <updated>2017-10-27T06:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在MAC环境下自定义shell终端的配色方案。<br>iterm2 + oh my zsh</p><a id="more"></a><h2 id="安装iterm2"><a href="#安装iterm2" class="headerlink" title="安装iterm2"></a>安装iterm2</h2><p><a href="http://www.iterm2.com/downloads.html" target="_blank" rel="noopener">下载地址</a></p><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，切换<code>dash</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p><p>切换为原来的<code>dash</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure></p><p>卸载oh-my-zsh:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uninstall_oh_my_zsh</span><br></pre></td></tr></table></figure></p><h2 id="设置配色方案"><a href="#设置配色方案" class="headerlink" title="设置配色方案"></a>设置配色方案</h2><p>使用 <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">Solarized</a> 配色方案:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/altercation/solarized.git</span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line"><span class="built_in">cd</span> solarized</span><br><span class="line"><span class="built_in">cd</span> vim-colors-solarized/colors</span><br><span class="line">mkdir -p ~/.vim/colors</span><br><span class="line">cp solarized.vim ~/.vim/colors/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改vim配色方案，和终端保持一致</span></span><br><span class="line">vi ~/.vimrc</span><br><span class="line"><span class="comment">#写入</span></span><br><span class="line">syntax <span class="built_in">enable</span></span><br><span class="line"><span class="built_in">set</span> background=dark</span><br><span class="line">colorscheme solarized</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置ls高亮</span></span><br><span class="line"><span class="comment">#安装coreutils</span></span><br><span class="line">brew install coreutils</span><br><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="comment">#写入</span></span><br><span class="line"><span class="built_in">export</span> CLICOLOR=1</span><br></pre></td></tr></table></figure></p><h2 id="设置语法高亮"><a href="#设置语法高亮" class="headerlink" title="设置语法高亮"></a>设置语法高亮</h2><p>使用 <a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source <span class="variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"</span> &gt;&gt; <span class="variable">$&#123;ZDOTDIR:-$HOME&#125;</span>/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></p><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>使用主题 <a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="noopener">agnoster</a>。   </p><h4 id="此款主题需要字体"><a href="#此款主题需要字体" class="headerlink" title="此款主题需要字体"></a>此款主题需要字体</h4><p><a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">下载地址</a>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更改配置文件</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"><span class="comment">#写入</span></span><br><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br></pre></td></tr></table></figure><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="http://image.lynth.cn/img/shell/zsh.png" alt="on-my-zsh"><br><img src="http://image.lynth.cn/img/shell/zsh1.png" alt="on-my-zsh"></p><blockquote><p>参考：<br><a href="http://www.vpsee.com/2013/09/use-the-solarized-color-theme-on-mac-os-x-terminal/" target="_blank" rel="noopener">在 Mac OS X 终端里使用 Solarized 配色方案</a><br><a href="http://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="noopener">iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】</a><br><a href="http://www.jianshu.com/p/e4973be9c9fb" target="_blank" rel="noopener">Mac下iTerm 2语法高亮配置及附带美化</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MAC环境下自定义shell终端的配色方案。&lt;br&gt;iterm2 + oh my zsh&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="https://yzllee.github.io/blog/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>writing-mode</title>
    <link href="https://yzllee.github.io/blog/2016/12/14/writing-mode/"/>
    <id>https://yzllee.github.io/blog/2016/12/14/writing-mode/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2020-05-08T05:33:55.548Z</updated>
    
    <content type="html"><![CDATA[<p><strong>writing-mode</strong> 是控制内联元素的显示的，和 float 属性有些类似，<strong>writing-mode</strong> 可以实现文字竖向的排版。</p><a id="more"></a><h3 id="writing-mode语法"><a href="#writing-mode语法" class="headerlink" title="writing-mode语法"></a>writing-mode语法</h3><p>writing-mode有两套语法，一套是IE私有的，一套是CSS规范属性。</p><h4 id="CSS3语法"><a href="#CSS3语法" class="headerlink" title="CSS3语法"></a>CSS3语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关键字值 */</span></span><br><span class="line"><span class="selector-tag">writing-mode</span>: <span class="selector-tag">horizontal-tb</span>;    <span class="comment">/* 默认值 */</span></span><br><span class="line"><span class="selector-tag">writing-mode</span>: <span class="selector-tag">vertical-rl</span>;</span><br><span class="line"><span class="selector-tag">writing-mode</span>: <span class="selector-tag">vertical-lr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局值-关键字 */</span></span><br><span class="line"><span class="selector-tag">writing-mode</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">writing-mode</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">writing-mode</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure><ul><li>默认值<strong>horizontal-tb</strong>表示文本流是水平方向(horizontal)的，元素是从上往下<strong>(tb:top-bottom)</strong>堆叠的。</li><li><strong>vertical-rl</strong>表示文本是垂直方向(vertical)展示，然后阅读的顺序是从右往左<strong>(rl:right-left)</strong>，跟我们古诗的阅读顺序一致。</li><li><strong>vertical-lr</strong>表示文本是垂直方向(vertical)展示，然后阅读的顺序还是默认的从左往右<strong>(lr:left-right)</strong>，也就是仅仅是水平变垂直。</li></ul><p>下面是各个值下的中英文表现对照（参考自<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode" target="_blank" rel="noopener">MDN</a>）：<br><img src="http://image.lynth.cn/img/writingmode/writing-mode.png" alt="对照表"><br><em>使用<strong>text-orientation:upright</strong>可让英文字符竖立，IE不支持，FF和Chrome支持。</em></p><h4 id="IE浏览器语法"><a href="#IE浏览器语法" class="headerlink" title="IE浏览器语法"></a>IE浏览器语法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ms-writing-mode: lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb</span><br></pre></td></tr></table></figure><ul><li><strong>lr-tb</strong><br>初始值。内容从左往右(left-right)，从上往下(top-bottom)水平流动，以及下一行水平元素在上一行元素的下面，所有符号都是直立定位。大部分的书写系统都是使用这种布局。</li><li><strong>rl-tb</strong><br>内容从右往左(right-left，从上往下(top-bottom)水平流动，以及下一行水平元素在上一行元素的下面，所有符号都是直立定位。这种布局适合从右往左书写的语言，例如阿拉伯语，希伯来语，塔安那文，和叙利亚语。</li><li><strong>tb-rl</strong><br>内容从上往下(top-bottom)，从右往左(right-left)垂直流动， 下一个垂直行定位于前一个垂直行的左边，全角符号直立定位，非全角符号(也可以被称作窄拉丁文或者窄假名符号)顺时针方向旋转90°。这种布局多见于东亚排版。</li><li><strong>bt-rl</strong><br>内容从下往上(bottom-top)，从右往左(right-left)垂直流动， 下一个垂直行定位于前一个垂直行的左边，全角符号直立定位，非全角符号(也可以被称作窄拉丁文或者窄假名符号)顺时针方向旋转90°。此布局多见于在东亚垂直排版从右往左的文本块上。</li><li><strong>tb-lr</strong><br>IE8+浏览器支持。 内容从上往下(top-bottom)，从左往右(left-right)垂直流动。下一个垂直行在前一个的右边。</li><li><strong>bt-lr</strong><br>IE8+浏览器支持。 内容从下往上(bottom-top)，从左往右(left-right)垂直流动。</li><li><strong>lr-bt</strong><br>IE8+浏览器支持。 内容从下往上(bottom-top)，从左往右(left-right)水平流动。下一个水平行在前一行的上面。</li><li><strong>rl-bt</strong><br>IE8+浏览器支持。内容从下往上(bottom-top)， 从右往左(right-left)水平流动。</li><li><strong>lr</strong><br>IE9+浏览器支持。在SVG和HTML元素上使用。等同于<strong>lr-tb</strong>.</li><li><strong>rl</strong><br>IE9+浏览器支持。在SVG和HTML元素上使用。等同于<strong>rl-tb</strong>.</li><li><strong>tb</strong><br>IE9+浏览器支持。在SVG和HTML元素上使用。等同于<strong>tb-rl</strong>.</li></ul><p>各个属性值的表现如下（参考自<a href="https://msdn.microsoft.com/en-us/library/ms531187%28v=vs.85%29.aspx" target="_blank" rel="noopener">微软</a>）<br><img src="http://image.lynth.cn/img/writingmode/writing-mode1.jpg" alt="对照表"></p><blockquote><p>参考：<br><a href="http://www.zhangxinxu.com/wordpress/?p=5352" target="_blank" rel="noopener">改变CSS世界纵横规则的writing-mode属性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;writing-mode&lt;/strong&gt; 是控制内联元素的显示的，和 float 属性有些类似，&lt;strong&gt;writing-mode&lt;/strong&gt; 可以实现文字竖向的排版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://yzllee.github.io/blog/tags/css/"/>
    
  </entry>
  
</feed>
